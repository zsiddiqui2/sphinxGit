# -*- coding: utf-8 -*-
"""
    sphinx.latexwriter
    ~~~~~~~~~~~~~~~~~~

    Custom docutils writer for LaTeX.

    Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
    docutils sandbox.

    :copyright: 2007 by Georg Brandl, Dave Kuhlman.
    :license: Python license.
"""

import re
import time

from docutils import frontend, nodes, languages, writers, utils


HEADER = r'''%% Generated by Sphinx.
\documentclass[%(papersize)s,%(pointsize)s]{manual}
\usepackage{hyperref}
\title{%(title)s}
\date{%(date)s}
\release{%(release)s}
\author{Guido van Rossum\\
  Fred L. Drake, Jr., editor}
\authoraddress{
  \strong{Python Software Foundation}\\
  Email: \email{docs@python.org}
}
\makeindex

'''

FOOTER = r''''
\printindex
\end{document}
'''


class LaTeXWriter(writers.Writer):

    supported = ('sphinxlatex',)

    settings_spec = ('No options here.', '', ())
    settings_defaults = {}

    output = None

    def __init__(self, config, buildername):
        writers.Writer.__init__(self)
        self.config = config

    def translate(self):
        try:
            visitor = LaTeXTranslator(self.document, self.config)
            self.document.walkabout(visitor)
            self.output = visitor.astext()
        except:
            import pdb, sys, traceback
            traceback.print_exc()
            tb = sys.exc_info()[2]
            pdb.post_mortem(tb)


TABLE_MODE_NONE = 0
TABLE_MODE_HEAD = 1
TABLE_MODE_BODY = 2

class TableSpec:
    def __init__(self):
        self.columnCount = 0
        self.mode = TABLE_MODE_NONE
    def getColumnCount(self): return self.columnCount
    def setColumnCount(self, columnCount): self.columnCount = columnCount
    def getMode(self): return self.mode
    def setMode(self, mode): self.mode = mode


class LaTeXTranslator(nodes.NodeVisitor):
    sectionnames = ["chapter", "chapter", "section", "subsection",
                    "subsubsection", "paragraph", "subparagraph"]

    def __init__(self, document, config):
        nodes.NodeVisitor.__init__(self, document)
        self.body = []
        self.options = {'papersize': 'a4paper', # XXX
                        'pointsize': '12pt',
                        'filename': document.settings.filename,
                        'title': '',
                        'release': config['release'],
                        'date': time.strftime(config.get('today_fmt', '%B %d, %Y')),
                        }
        self.context = []
        self.verbatim = 0
        self.this_is_the_title = 1
        self.sectionlevel = 0 # XXX starts with chapter now
        self.highlightlang = 'python'

    def astext(self):
        return (HEADER % self.options) + \
               u''.join(self.body) + \
               (FOOTER % self.options)

    def visit_document(self, node):
        self.body.append('\\begin{document}\n\\maketitle\n')
    def depart_document(self, node):
        pass

    def visit_highlightlang(self, node):
        self.highlightlang = node['lang']
        raise nodes.SkipNode

    def visit_comment(self, node):
        raise nodes.SkipNode

    def visit_section(self, node):
        if not self.this_is_the_title:
            self.sectionlevel += 1
    def depart_section(self, node):
        self.sectionlevel -= 1

    def visit_glossary(self, node):
        raise nodes.SkipNode # XXX

    def visit_transition(self, node):
        self.body.append('\n\n\\hrule{}\n\n')

    def depart_transition(self, node):
        pass

    def visit_title(self, node):
        if self.this_is_the_title:
            if len(node.children) != 1 and not isinstance(node.children[0], Text):
                raise RuntimeError("title is not a Text node")
            self.options['title'] = node.children[0].astext()
            self.this_is_the_title = 0
            raise nodes.SkipNode
        elif isinstance(node.parent, nodes.section):
            self.body.append('\n\n')
            self.body.append(r'\%s{' % self.sectionnames[self.sectionlevel])
            self.context.append('}\n')
        else:
            raise RuntimeError("XXX title without section")
    def depart_title(self, node):
        self.body.append(self.context.pop())

    def visit_field_list(self, node):
        raise nodes.SkipNode # XXX

    def visit_desc(self, node):
        raise nodes.SkipNode # XXX

    def visit_seealso(self, node):
        raise nodes.SkipNode # XXX

    def visit_rubric(self, node):
        raise nodes.SkipNode # XXX

    def visit_footnote(self, node):
        raise nodes.SkipNode # XXX

    def visit_table(self, node):
        self.tableSpec = TableSpec()
    def depart_table(self, node):
        self.tableSpec = None

    def visit_colspec(self, node):
        pass
    def depart_colspec(self, node):
        pass

    def visit_tgroup(self, node):
        columnCount = int(node.get('cols', 0))
        self.tableSpec.setColumnCount(columnCount)
        if columnCount == 2:
            self.body.append('\\begin{tableii}{l|l}{textrm}')
        elif columnCount == 3:
            self.body.append('\\begin{tableiii}{l|l|l}{textrm}')
        elif columnCount == 4:
            self.body.append('\\begin{tableiv}{l|l|l|l}{textrm}')
        elif columnCount == 5:
            self.body.append('\\begin{tablev}{l|l|l|l|l}{textrm}')
    def depart_tgroup(self, node):
        if self.tableSpec.getColumnCount() == 2:
            self.body.append('\n\\end{tableii}\n')
        elif self.tableSpec.getColumnCount() == 3:
            self.body.append('\n\\end{tableiii}\n')
        elif self.tableSpec.getColumnCount() == 4:
            self.body.append('\n\\end{tableiv}\n')
        elif self.tableSpec.getColumnCount() == 5:
            self.body.append('\n\\end{tablev}\n')

    def visit_thead(self, node):
        self.tableSpec.setMode(TABLE_MODE_HEAD)
    def depart_thead(self, node):
        self.tableSpec.setMode(TABLE_MODE_NONE)

    def visit_tbody(self, node):
        self.tableSpec.setMode(TABLE_MODE_BODY)
    def depart_tbody(self, node):
        self.tableSpec.setMode(TABLE_MODE_NONE)

    def visit_row(self, node):
        if self.tableSpec.getMode() == TABLE_MODE_HEAD:
            pass
        elif self.tableSpec.getMode() == TABLE_MODE_BODY:
            if self.tableSpec.getColumnCount() == 2:
                self.body.append('\n\\lineii')
            elif self.tableSpec.getColumnCount() == 3:
                self.body.append('\n\\lineiii')
            elif self.tableSpec.getColumnCount() == 4:
                self.body.append('\n\\lineiv')
            elif self.tableSpec.getColumnCount() == 5:
                self.body.append('\n\\linev')
    def depart_row(self, node):
        if self.tableSpec.getMode() == TABLE_MODE_HEAD:
            pass
        elif self.tableSpec.getMode() == TABLE_MODE_BODY:
            pass

    def visit_entry(self, node):
        if self.tableSpec.getMode() == TABLE_MODE_HEAD:
            #self.body.append('%% [(visit_entry) text: +%s+]' % node.astext())
            self.body.append('{%s}' % node.astext().strip(' '))
            raise nodes.SkipNode
        elif self.tableSpec.getMode() == TABLE_MODE_BODY:
            #self.body.append('%% [(visit_entry) text: +%s+]' % node.astext())
            self.body.append('{%s}' % node.astext().strip(' '))
            raise nodes.SkipNode
    def depart_entry(self, node):
        pass
##         if self.tableSpec.getMode() == TABLE_MODE_HEAD:
##             self.body.append('}')
##         elif self.tableSpec.getMode() == TABLE_MODE_BODY:
##             self.body.append('}')

    def visit_bullet_list(self, node):
        self.body.append('\\begin{itemize}\n' )
    def depart_bullet_list(self, node):
        self.body.append('\\end{itemize}\n' )

    def visit_enumerated_list(self, node):
        self.body.append('\\begin{enumerate}\n' )
    def depart_enumerated_list(self, node):
        self.body.append('\\end{enumerate}\n' )

    def visit_list_item(self, node):
        # Append "{}" in case the next character is "[", which would break
        # LaTeX's list environment (no numbering and the "[" is not printed).
        self.body.append(r'\item {} ')
    def depart_list_item(self, node):
        self.body.append('\n')

    def visit_definition_list(self, node):
        self.body.append('\\begin{description}\n')
    def depart_definition_list(self, node):
        self.body.append('\\end{description}\n')

    def visit_definition_list_item(self, node):
        pass
    def depart_definition_list_item(self, node):
        pass

    def visit_term(self, node):
        self.body.append('\\item[')
    def depart_term(self, node):
        # definition list term.
        self.body.append(':]\n')

    def visit_classifier(self, node):
        pass # XXX
    def depart_classifier(self, node):
        pass

    def visit_definition(self, node):
        pass
    def depart_definition(self, node):
        self.body.append('\n')

    def visit_paragraph(self, node):
        self.body.append('\n')
    def depart_paragraph(self, node):
        self.body.append('\n')

    def visit_centered(self, node):
        self.body.append('\n\\begin{centering}')
    def depart_centered(self, node):
        self.body.append('\n\\end{centering}')

    def visit_note(self, node):
        self.body.append('\n\\note{')
    def depart_note(self, node):
        self.body.append('}\n')

    def visit_warning(self, node):
        self.body.append('\n\\warning{')
    def depart_warning(self, node):
        self.body.append('}\n')

    def visit_versionmodified(self, node):
        #self.body.append('\n\\vmod{')
        pass
    def depart_versionmodified(self, node):
        #self.body.append('}\n')
        pass

    def visit_target(self, node):
        if not (node.has_key('refuri') or node.has_key('refid')
                or node.has_key('refname')):
            for id in node['ids']:
                self.body.append(r'\hypertarget{%s}{' % id)
            self.context.append('}' * len(node['ids']))
        else:
            self.context.append('')
    def depart_target(self, node):
        self.body.append(self.context.pop())

    def visit_index(self, node):
        raise nodes.SkipNode # XXX

    def visit_reference(self, node):
        pass # XXX
    def depart_reference(self, node):
        pass

    def visit_pending_xref(self, node):
        pass
    def depart_pending_xref(self, node):
        pass

    def visit_emphasis(self, node):
        self.body.append(r'\emph{')
    def depart_emphasis(self, node):
        self.body.append('}')

    def visit_literal_emphasis(self, node):
        self.body.append(r'\emph{') # XXX
    def depart_literal_emphasis(self, node):
        self.body.append('}')

    def visit_strong(self, node):
        self.body.append(r'\textbf{')
    def depart_strong(self, node):
        self.body.append('}')

    def visit_literal(self, node):
        content = self.encode(node.astext().strip())
        if re.search('[ \t\n]', content):
            self.body.append(r'\samp{%s}' % content)
        else:
            self.body.append(r'\code{%s}' % content)
        raise nodes.SkipNode

    def visit_footnote_reference(self, node):
        pass #XXX
    def depart_footnote_reference(self, node):
        pass

    def visit_literal_block(self, node):
        self.body.append('\n\\begin{verbatim}')
        self.verbatim = 1
    def depart_literal_block(self, node):
        self.body.append('\\end{verbatim}\n')
        self.verbatim = 0

    def visit_line_block(self, node):
        """line-block:
        * whitespace (including linebreaks) is significant
        * inline markup is supported.
        * serif typeface
        """
        self.body.append('\\begin{flushleft}\n')
        #self.insert_none_breaking_blanks = 1
        #self.line_block_without_mbox = 1
        #if self.line_block_without_mbox:
        #    self.insert_newline = 1
        #else:
        #    self.mbox_newline = 1
        #    self.body.append('\\mbox{')
    def depart_line_block(self, node):
        #if self.line_block_without_mbox:
        #    self.insert_newline = 0
        #else:
        #    self.body.append('}')
        #    self.mbox_newline = 0
        #self.insert_none_breaking_blanks = 0
        self.body.append('\n\\end{flushleft}\n')

    def visit_line(self, node):
        pass
    def depart_line(self, node):
        pass

    def visit_block_quote(self, node):
        # If the block quote contains a single object and that object
        # is a list, then generate a list not a block quote.
        # This lets us indent lists.
        done = 0
        if len(node.children) == 1:
            child = node.children[0]
            if isinstance(child, nodes.bullet_list) or \
                    isinstance(child, nodes.enumerated_list):
                done = 1
        if not done:
            self.body.append('\\begin{quote}\n')
    def depart_block_quote(self, node):
        done = 0
        if len(node.children) == 1:
            child = node.children[0]
            if isinstance(child, nodes.bullet_list) or \
                    isinstance(child, nodes.enumerated_list):
                done = 1
        if not done:
            self.body.append('\\end{quote}\n')

    replacements = [
        (u"\\", ur"\textbackslash{}"),
        (u"$", ur"\$"),
        (u"&", ur"\&"),
        (u"#", ur"\#"),
        (u"_", ur"\_"),
        (u"{", ur"\{"),
        (u"}", ur"\}"),
        (u"¶", ur"\P{}"),
        (u"§", ur"\S{}"),
        (u"~", ur"\textasciitilde{}"),
        (u"<", ur"\textless{}"),
        (u">", ur"\textgreater{}"),
        (u"^", ur"\textasciicircum{}"),
    ]

    def encode(self, text):
        if self.verbatim:
            return text
        for x, y in self.replacements:
            text = text.replace(x, y)
        return text

    def visit_Text(self, node):
        self.body.append(self.encode(node.astext()))
    def depart_Text(self, node):
        pass

    def unknown_visit(self, node):
        raise NotImplementedError("Unknown node: " + node.__class__.__name__)
